#pragma config(Sensor, S1,     touch_500,      sensorTouch)
#pragma config(Sensor, S2,     touch_1000,     sensorTouch)
#pragma config(Sensor, S3,     error,          sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define distance_1000 95//24
#define distance_500 46//26.5
#define DIAMETER 55


float convert(float distance){

	float angle;
	angle = (360 * distance / DIAMETER / PI);
	return angle;
}


task main()
{


	int count;
	int count_10000 =0;
	int count_5000=0;
	int count_1000=0;
	int total_coin_500 =0;
	int print_money = 0;
	int coin_500_distance =0;
	int total_1000 =0;
	int total_1000_distance =0;

	
	
	while(1){

			
			nxtDisplayTextLine(1, "count = %d ", count);
			nxtDisplayTextLine(2, "input_money = %d",print_money);
			nxtDisplayTextLine(3,"total_1000 = %d",total_1000);
			nxtDisplayTextLine(4,"%d",SensorValue(touch_500));
			nxtDisplayTextLine(5,"%d",SensorValue(touch_1000));
			nxtDisplayTextLine(6,"%d",SensorValue(error));
			total_coin_500 = count_10000 * 20 + count_5000 * 10 + count_1000 * 2;
			print_money = count_10000* 10000 + count_5000* 5000 + count_1000 * 1000;
			coin_500_distance = (int) convert((float)distance_500 * total_coin_500);
			total_1000 = count_10000 * 10 + count_5000 * 5 + count_1000 *1;
			total_1000_distance = (int) convert((float)distance_1000 * total_1000);
		
		if(bQueuedMsgAvailable()){
				count = messageParm[0];
   
		
		if(count ==1){
			
			count_1000++;

		}

		if(count ==2){
			
				
			count_5000++;


		}

		if(count ==3){


			count_10000++;

		}
			
			wait1Msec(100);
			ClearMessage();

		}
		
		if(SensorValue(touch_500) ==1){
			
			
				nMotorEncoder[motorB] = 0;
				while(nMotorEncoder[motorB] >-	coin_500_distance){
				nMotorEncoderTarget[motorB] = -	coin_500_distance;
				motor[motorB] = -50;
			
				}
				motor[motorB] = 0;
				motor[motorB] = 0;
				
		
				count_1000 =0;
				count_5000 = 0;
				count_10000 = 0;
			}

			if(SensorValue(touch_1000) == 1){
			
				nMotorEncoder[motorC] = 0;
				while(nMotorEncoder[motorC] >-	total_1000_distance){
				nMotorEncoderTarget[motorC] = -	total_1000_distance;
				nMotorEncoderTarget[motorA] = total_1000_distance;
				motor[motorC] = -50;
				motor[motorA] = -50;
				}
				motor[motorA] = 0;
				motor[motorC] = 0;
				
		
				count_1000 =0;
				count_5000 = 0;
				count_10000 = 0;
		}
		
			if(SensorValue(error) == 1){
			while(SensorValue(error) == 1){
				motor[motorC] = -20;
				motor[motorA] = -20;
				}
				motor[motorA] = 0;
				motor[motorC] = 0;
	}
			
			
						
}

			
}
	
	
	