#pragma config(Sensor, S1,     touch_100,      sensorTouch)
#pragma config(Sensor, S4,     touch_500,      sensorTouch)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define distance_100 30//24
#define distance_500 35//26.5
#define DIAMETER 55


float convert(float distance){

	float angle;
	angle = (360 * distance / DIAMETER / PI);
	return angle;
}


task main()
{


	int count;
	int count_10000 =0;
	int count_5000=0;
	int count_1000=0;
	int total_coin_100 =0;
	int total_coin_500 =0;
	int print_money = 0;
	int coin_100_distance =0;
	int coin_500_distance =0;
	int x = 0;

	
	
	while(1){

			
			nxtDisplayTextLine(2, "count = %d ", count);
			nxtDisplayTextLine(3, "%d",coin_500_distance);
			nxtDisplayTextLine(4, "%d",SensorValue(touch_100));
			nxtDisplayTextLine(5, "%d",SensorValue(touch_500));
			nxtDisplayTextLine(6,"%d",total_coin_100);
			nxtDisplayTextLine(7,"%d",total_coin_500);
			
			total_coin_100 = count_10000 * 100 + count_5000 * 50 + count_1000 * 10;
			total_coin_500 = count_10000 * 20 + count_5000 * 10 + count_1000 * 2;
		
			print_money = count_10000* 10000 + count_5000* 5000 + count_1000 * 1000;
			coin_100_distance = (int) convert((float)distance_100 * total_coin_100);
			coin_500_distance = (int) convert((float)distance_500 * total_coin_500);
		
		if(bQueuedMsgAvailable()){
				count = messageParm[0];
   
		
		if(count ==1){
			
			count_1000++;

		}

		if(count ==2){
			
				
			count_5000++;


		}

		if(count ==3){


			count_10000++;

		}
			
			wait1Msec(150);
			ClearMessage();

		}
		
		
		if(SensorValue(touch_100) == 1){
			x = 1;
		}
		else if(SensorValue(touch_500) == 1){
			x = 2;
		}
		else{
			x = 3;
		}
		
		
		switch(x){
			case 1:
				nMotorEncoder[motorC] = 0;
				while(nMotorEncoder[motorC] >-	coin_100_distance){
				nMotorEncoderTarget[motorC] = -	coin_100_distance;
				motor[motorC] = -50;
			
				}
				motor[motorA] = 0;
				motor[motorC] = 0;
				
		
				count_1000 =0;
				count_5000 = 0;
				count_10000 = 0;
				break;
				
				
			case 2:
				nMotorEncoder[motorA] = 0;
				while(nMotorEncoder[motorA] >-	coin_500_distance){
				nMotorEncoderTarget[motorA] = -	coin_500_distance;
				motor[motorA] = -50;
			
				}
				motor[motorA] = 0;
				motor[motorC] = 0;
				count_1000 =0;
				count_5000 = 0;
				count_10000 = 0;
				break;
				
				default : 
				motor[motorA] = 0;
				motor[motorC] = 0;
				break;
				
			}
						
}

			
}
	
	
	